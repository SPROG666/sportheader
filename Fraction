struct Fraction {
	using T = long long;
	T a = 0, b = 1;
	void Norm() {
		T g = gcd(a, b);
		a /= g, b /= g;
		if (b < 0)a *= -1, b *= -1;
	}
	void abs() { if (a < 0)a *= -1; }
	void rev() { swap(a, b); }
	Fraction() = default;
	template <typename T1>
	Fraction(T1 x) : a(x) { Norm(); }
	template <typename T1, typename T2>
	Fraction(T1 x, T2 y) : a(x), b(y) { Norm(); }
	
	Fraction& operator+=(Fraction f) {
		a = a * f.b + f.a * b;
		b *= f.b;
		Norm();
		return *this;
	}
	Fraction& operator-=(Fraction f) {
		a = a * f.b - f.a * b;
		b *= f.b;
		Norm();
		return *this;
	}
	Fraction& operator*=(Fraction f) {
		a *= f.a;
		b *= f.b;
		Norm();
		return *this;
	}
	Fraction& operator/=(Fraction f) {
		a *= f.b;
		b *= f.a;
		Norm();
		return *this;
	}
	string operator()(string s = "/") {
		return to_string(a) + s + to_string(b);
	}
};

long long tol(Fraction f) {
	return long long(f.a / f.b);
}
long double tod(Fraction f) {
	return long double(1.0) * f.a / f.b;
}
Fraction todd(Fraction f) {
	f.a %= f.b;
	return f;
}
Fraction tof(long double a) {
	Fraction f;
	string s = to_string(a);
	if (s.find('.') == s.npos) f.a = a;
	else f.a = a * pow(10, (s.size() - s.find('.'))), f.b = pow(10, (s.size() - s.find('.')));
	return f;
}
Fraction tof(string x) {
	Fraction f;
	if (x.find('/') == x.npos && x.find(':') == x.npos && x.find('.') == x.npos)
		f.a = stoll(x);
	else if (x.find('/') != x.npos)
		f.a = stoll(x.substr(0, x.find('/'))), f.b = stoll(x.substr(x.find('/') + 1));
	else if (x.find(':') != x.npos)
		f.a = stoll(x.substr(0, x.find(':'))), f.b = stoll(x.substr(x.find(':') + 1));
	else
		f = tof(stod(x));
	f.Norm();
	return f;
}

istream& operator>>(istream& in, Fraction& f) {
	string s; in >> s;
	if (s.find('/') == s.npos && s.find(':') == s.npos && s.find('.') == s.npos)
		f.a = stoll(s), cin >> f.b;
	else if (s.find('/') != s.npos)
		f.a = stoll(s.substr(0, s.find('/'))), f.b = stoll(s.substr(s.find('/') + 1));
	else if (s.find(':') != s.npos)
		f.a = stoll(s.substr(0, s.find(':'))), f.b = stoll(s.substr(s.find(':') + 1));
	else
		f = tof(stod(s));
	f.Norm();
	return in;
}
ostream& operator<<(ostream& out, Fraction f) {
	out << f.a * 1.0 / f.b;
	return out;
}

Fraction operator+(Fraction f) {
	return f;
}
Fraction operator-(Fraction f) {
	f.a *= -1;
	return f;
}
Fraction operator+(Fraction f1, Fraction f2) {
	f1 += f2;
	return f1;
}
Fraction operator-(Fraction f1, Fraction f2) {
	f1 -= f2;
	return f1;
}
Fraction operator*(Fraction f1, Fraction f2) {
	f1 *= f2;
	return f1;
}
Fraction operator/(Fraction f1, Fraction f2) {
	f1 /= f2;
	return f1;
}

bool operator<(const Fraction f1, const Fraction f2) {
	return f1.a * f2.b < f1.b * f2.a;
}
bool operator>(const Fraction f1, const Fraction f2) {
	return f1.a * f2.b > f1.b * f2.a;
}
bool operator<=(const Fraction f1, const Fraction f2) {
	return f1.a * f2.b <= f1.b * f2.a;
}
bool operator>=(const Fraction f1, const Fraction f2) {
	return f1.a * f2.b >= f1.b * f2.a;
}
bool operator==(const Fraction f1, const Fraction f2) {
	return f1.a * f2.b == f1.b * f2.a;
}
bool operator!=(const Fraction f1, const Fraction f2) {
	return f1.a * f2.b != f1.b * f2.a;
}

Fraction abs(Fraction f) {
	f.a = abs(f.a);
	return f;
}
Fraction min(const Fraction f1, const Fraction f2) {
	return (f1 < f2 ? f1 : f2);
}
Fraction max(const Fraction f1, const Fraction f2) {
	return (f1 > f2 ? f1 : f2);
}
Fraction rev(Fraction f) {
	swap(f.a, f.b);
	return f;
}

Fraction tof(string a, string b) {
	return tof(a) / tof(b);
}
Fraction tof(long double a, string b) {
	return tof(a) / tof(b);
}
Fraction tof(string a, long double b) {
	return tof(a) / tof(b);
}
Fraction tof(long double a, long double b) {
	return tof(a) / tof(b);
}
